import java.util.ArrayList;
import java.util.List;


/**
 * Represents an Abstract Syntax Tree (AST) for a given parse tree.
 * The AST is generated by removing unnecessary terminals and non-terminals from the parse tree.
 * ASTs can be found in test/ast-2/ for parse tress in test/ast-1/.
 */
public class AST extends ParseTree {
    private Symbol current;

    /**
     * Constructs an AST object by generating the AST from a given parse tree.
     * @param parseTree The parse tree to generate the AST from.
     */
    public AST(ParseTree parseTree) {
        super(parseTree.getLabel(), parseTree.getChildren());
        this.children = generateAST(parseTree);
    }

    /**
     * Generates the Abstract Syntax Tree (AST) for a given parse tree.
     * @param parseTree The parse tree to generate the AST from.
     * @return The list of parse trees representing the AST.
     */
    public List<ParseTree> generateAST(ParseTree parseTree) {
    List<ParseTree> children = new ArrayList<ParseTree>();
    for (ParseTree child : parseTree.getChildren()) {
        if (child.getChildren().isEmpty()) {
            //Terminals that are unnecessary
            current = child.getLabel();
            switch (current.getType()) {
                //For each terminal, add it to the list of children
                case EPSILON:
                    break;
                case LBRACK:
                    break;
                case RBRACK:
                    break;
                default:
                    children.add(child);
            }
        } else {
            //Variables that are unnecessary
            current = child.getLabel();
            switch (current.getValue().toString()) {
                //For each non-terminal, add its children to the list of children
                case "Instruction":
                    for (ParseTree grandchild : generateAST(child)) {
                        if (grandchild.getLabel().isNonTerminal()) {
                            children.add(grandchild);
                        }
                    }
                    break;
                case "InstListTail":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "Comp":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "ExprArith'":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "Prod'":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "IfTail":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "Cond'":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                case "Conj'":
                    for (ParseTree grandchild : generateAST(child)) {
                        children.add(grandchild);
                    }
                    break;
                default:
                    ParseTree parent = new ParseTree(current, generateAST(child));
                    children.add(parent);
            }
        }
    }
    return children;
    }
}
